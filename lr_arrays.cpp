/***
* Цель           : Дан одномерный целочисленный массив AVec. Найти
* минимальный элемент среди положительных. После него сдублировать все
* отрицательные элементы.
* Caution        : В случае, когда есть несколько равных минимальных
* положительных элементов, дублировать все отрицательные элементы только
* после первого из них.
***/

#include <iostream>
#include <algorithm>
#include <fstream>
using namespace std;

// Объявление глобальных переменных:
const string FILENAME = "source.txt"; // Имя файла исходных данных
const int NMax = 50; // Максимальный размер массива AVec

int main()
{
    // Подключение поддержки русского языка в консоли вывода:
    setlocale(LC_ALL, "Russian");

    // Объявление переменных:
    ifstream source; // Поток для чтения данных из файла
    int AVec[NMax]; // Одномерный целочисленный массив AVec
    int N; // Текущий размер массива AVec
    double tmp; // Вспомогательная переменная для проверки корректности вводимых из файла чисел
    int ValueOfMinimalPositiveElement; // Значение минимального положительного элемента AVec
    int IndexOfMinimalPositiveElement; // Индекс минимального положительного элемента AVec (если минимальных чисел несколько, берется меньший индекс)
    int CountOfDuplicatedElements; // Хранит количество сдублированных элементов
    int MestoDlyaDublirovaniya; // Индекс, куда производится дублирование элемента

    /***************************************В**********************
                    Часть 1: Чтение данных из файла
    *************************************************************/

    // Открытие файла исходных данных:
    source.open(FILENAME);

    // Проверка, удалось ли открыть файл:
    if (!source) {
        cout << "Ошибка #1. Не удалось открыть файл." << endl;
        return 1;
    }

    // Проверка, не оказался ли файл пустым:
    if (source.peek() == EOF) { // source.peek() возвращает EOF, если файл пуст
        cout << "Ошибка №2. Файл пуст." << endl;
        return 2;
    }

    // Считывание N из файла в переменную tmp:
    source >> tmp;

    // Проверка, является ли введенное из файла значение N числом:
    if (source.fail()) {
        cout << "Ошибка №3. Введенное из файла значение N не является числом." << endl;
        return 3;
    }

    // Проверка, является ли введенное из файла значение N натуральным числом:
    if (tmp != int(tmp)) {
        cout << "Ошибка №4. Введенное из файла значение N не является натуральным числом." << endl;
        return 4;
    }

    // Присвоим переменной N значение tmp:
    N = int(tmp);

    // Проверка, лежит ли значение N в области корректных значений:
    if ((N<1)||(N>NMax/2)) {
        cout << "Ошибка №5. Значение N некорректно, оно должно быть в интервале [1;NMax/2]." << endl;
        return 5;
    }

    // Вывод N:
    cout << "N = " << N << endl;

    // Ввод AVec из файла:
    for (int i = 0; i < N; i++) {

        // Проверка, не пришли ли мы к концу файла:
        if (source.eof()) {
            cout << "Ошибка №6. В файле недостаточно аргументов для ввода всего массива AVec." << endl;
            return 6;
        }

        // Считывание элемента массива в переменную tmp:
        source >> tmp;

        // Проверка, является ли введенный элемент массива числом:
        if (source.fail()) {
            cout << "Ошибка №7. Один из элементов массива не является числом." << endl;
            return 7;
        }

        // Проверка, является ли введенный элемент массива натуральным числом:
        if (tmp != int(tmp)) {
            cout << "Ошибка №8. Один из элементов массива не является натуральным числом." << endl;
            return 8;
        }

        // Присвоим переменной AVec[i] значение tmp:
        AVec[i] = int(tmp);

    } // Конец блока "Ввод AVec из файла"

    // Проверка, не осталось ли в файле лишних аргументов:
    if (!source.eof()) {
        cout << "Ошибка №9. В файле слишком много аргументов." << endl;
        return 9;
    }

    // Вывод считанного массива AVec:
    cout << "AVec = ";
    for (int i = 0; i < N; i++) {
        cout << AVec[i] << " ";
    }
    cout << endl << endl;


    /*************************************************************
               Часть 2: Нахождение минимального элемента
                        среди положительных
    *************************************************************/

    // Пока не найден ни один положительный элемент, значение и индекс минимального из них примем равными -1:
    ValueOfMinimalPositiveElement = -1;
    IndexOfMinimalPositiveElement = -1;

    // Пробуем найти хотя бы один положительный элемент в массиве AVec:
    for (int i = 0; i < N; i++) {

        if (AVec[i] > 0) { // Если i-ый элемент массива положителен
            ValueOfMinimalPositiveElement = AVec[i];
            IndexOfMinimalPositiveElement = i;
            break;
        }

    }

    // Проверим, удалось ли найти хотя бы один положительный элемент:
    if (IndexOfMinimalPositiveElement == -1) {
        cout << "В массиве AVec нет положительных элементов.\n\n";
        return 0;
    }

    // Сравниваем найденный положительный элемент с остальными
    // положительными элементами и выбираем минимальный из них
    for (int i = IndexOfMinimalPositiveElement; i < N; i++) {

        if ((AVec[i] > 0) && (AVec[i] < ValueOfMinimalPositiveElement)) { // Если i-ый элемент массива положителен и меньше минимального
            ValueOfMinimalPositiveElement = AVec[i];
            IndexOfMinimalPositiveElement = i;
        }
        
    }

    cout << "Значение минимального положительного элемента = " << ValueOfMinimalPositiveElement << endl;
    cout << "Индекс минимального положительного элемента = " << IndexOfMinimalPositiveElement << endl << endl;

    /*************************************************************
               Часть 3: Дублирование отрицательных элементов
    *************************************************************/

    // Пока не был сдублирован ни один элемент, количество сдублированных элементов равно 0:
    CountOfDuplicatedElements = 0;

    // Сдублируем все отрицательные элементы стоящие ДО минимального положительного:
    for (int i = 0; i < IndexOfMinimalPositiveElement; i++) {

        if (AVec[i] < 0) { // Если i-ый элемент массива отрицателен

            N++; // Расширим массив

            // Вычислим тот индекс, на который будем дублировать отрицательный элемент:
            MestoDlyaDublirovaniya = IndexOfMinimalPositiveElement + CountOfDuplicatedElements + 1;

            // Сдвинем на один шаг вправо все элементы массива, стоящие справа от места, куда будем дублировать отрицательный элемент:
            for (int j = N-1; j > MestoDlyaDublirovaniya; j--) {
                AVec[j] = AVec[j-1];
            }

            // Сдублируем i-ый элемент массива 
            AVec[MestoDlyaDublirovaniya] = AVec[i];

            // Обновим счетчик отрицательных элементов;
            CountOfDuplicatedElements++;

        }

    } // Конец блока "Сдублируем все отрицательные элементы стоящие ДО минимального положительного"
    
    // Сдублируем все отрицательные элементы стоящие ПОСЛЕ минимального положительного и уже сдублированных элементов:
    for (int i = IndexOfMinimalPositiveElement + CountOfDuplicatedElements + 1; i < N; i++) {

        if (AVec[i] < 0) { // Если i-ый элемент массива отрицателен

            N++; // Расширим массив

             // Вычислим тот индекс, на который будем дублировать отрицательный элемент:
            MestoDlyaDublirovaniya = IndexOfMinimalPositiveElement + CountOfDuplicatedElements + 1;

            // Сдвинем на один шаг вправо все элементы массива, стоящие справа от места, куда будем дублировать отрицательный элемент:
            for (int j = N - 1; j > MestoDlyaDublirovaniya; j--) {
                AVec[j] = AVec[j - 1];
            }

            // Учтем, что при сдвиге i-ый элемент так же сдвинулся на один шаг вправо:
            i++;

            // Сдублируем i-ый элемент массива 
            AVec[MestoDlyaDublirovaniya] = AVec[i];

            // Обновим счетчик отрицательных элементов;
            CountOfDuplicatedElements++;

        }

    } // Конец блока "Сдублируем все отрицательные элементы стоящие ПОСЛЕ минимального положительного и уже сдублированных элементов"

    // Проверим, нашлось ли хоть одно отрицательное число:
    if (CountOfDuplicatedElements == 0) {
        cout << "В массиве AVec нет отрицательных элементов.\n\n";
        return 0;
    }

    // Выведем обновленный массив AVec:
    cout << "Обновленный AVec = ";
    for (int i = 0; i < N; i++) {
        cout << AVec[i] << " ";
    }
    cout << endl << endl;

    return 0;
}