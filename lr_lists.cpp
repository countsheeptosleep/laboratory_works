#include <iostream>

using namespace std;

// Двунаправленный символьный список
struct list {
	char a;
	list* prev;
	list* next;
};

// Основные функции интерфейса:
void list_create(list* l); // Создание списка
void list_print(list* l); // Вывод списка (значения и индексы)
void list_delete(list* l); // Удаление списка

// Дополнительные функции интерфейса:
void list_find_max(list* l); // (2, разрешено) Поиск в списке элемента с максимальным значением с получением его номера в списке (повторное вхождение одного и того же значения разрешено)
void insert_in_beginning(list* l); // (3) Включение нового элемента в начало списка
void delete_from_beginning(list* l); // (6) Удаление элемента из начала списка

// Основная программа
int main()
{
	setlocale(LC_ALL, "Russian");

	list list; // Объяляем переменную для списка
	
	list_create(&list); // Вызываем функцию создания списка
	list_print(&list); // Напечатаем список

	list_find_max(&list); // Найдем в списке максимальный элемент

	insert_in_beginning(&list); // Включение нового элемента в начало списка
	list_print(&list); // Напечатаем список

	delete_from_beginning(&list); // Удаление элемента из начала списка
	list_print(&list); // Напечатаем список

	list_delete(&list);

	return 0;
}

// Создание списка
void list_create(list* l) {

	l->a = NULL;
	l->prev = NULL;
	l->next = NULL;

	int list_length;
	char x;

	cout << "Введите желаемый размер списка: ";

	cin >> list_length;

	cout << "Введите элементы списка: ";

	// Введем первый элемент в список:
	cin >> x;
	l->a = x;

	// Введем оставшиеся элементы в список:
	for (int i = 0; i < list_length - 1; i++) {
		
		// Считывание очередного значения:
		cin >> x;

		// Создадим новый узел:
		list* new_node = new list;

		// Свяжем новый узел с предудыщим:
		l->next = new_node; 
		new_node->prev = l; 

		// Сделаем новый узел ведущим в тупик:
		new_node->next = NULL;

		// Введем в новый узел считанное значение:
		new_node->a = x;

		// Новый узел теперь последний в списке:
		l = new_node;
		
	}
	
	cout << endl;
}



// Вывод списка (значения и индексы)
void list_print(list* l) {

	// Итератор для определения индекса элемента
	int i = 0;

	cout << "Список: ";

	// Перебираем звенья листа до тупика
	while (l != NULL) {
		
		// Выводим очередное значение элемента и его индекс
		cout << l->a << " (index " << i << "); ";

		// Переходим к следующему звену списка (или в тупик)
		l = l->next;
		
		// Увеличиваем на единицу индекс
		i++;
	}

	cout << endl << endl;
}

void list_delete(list* l) {


	// Проходим до тупика весь список
	while (l->next != NULL) {

		// Переходим на следующий узел
		l = l->next;

		// Удаляем предудыщий элемент
		l->prev->a = NULL;
		l->prev->next = NULL;

	}

	// Удаляем значение из последнего элемента
	l->a = NULL;
}

// (2, разрешено) Поиск в списке элемента с максимальным значением с получением его номера в списке (повторное вхождение одного и того же значения разрешено)
void list_find_max(list* l) {

	int i = 0; // Итератор 
	char max = l->a; // Максимальный элемент
	int i_max = i; // Индекс максимального элемента

	// Перебираем звенья списка
	while (l->next != NULL) {

		// Прыгаем на следующее звено
		l = l->next;
		i++;

		// Сравниваем значение с раннее найденным максимумом
		if (l->a > max) {
			max = l->a;
			i_max = i;
		}
	}

	cout << "Максимум в списке: " << max << " (index " << i_max << ")" << endl << endl;

}


// (3) Включение нового элемента в начало списка
void insert_in_beginning(list* l) {

	// Значение нового элемента
	char x;

	cout << "Введите новый элемент, который вставим в начало списка: ";

	// Считывание значения нового элемента
	cin >> x;

	// Создадим новый узел
	list* newnode = new list;

	
	// Новый узел помещаем между первым и вторым, и значение первого узла переносим в этот новый узел
	if (l->next != NULL) {
		newnode->next = l->next;
		newnode->prev = l;
		newnode->a = l->a;
		l->next->prev = newnode;
		l->next = newnode;

		// В начале списка оказывается новый элемент
		l->a = x;

	}
	else {
		newnode->next = NULL;
		newnode->prev = l;
		newnode->a = l->a;
		l->next = newnode;

		// В начале списка оказывается новый элемент
		l->a = x;
	}


}



// (6) Удаление элемента из начала списка
void delete_from_beginning(list* l) {

	cout << "Удаляем первый элемент" << endl;

	// Указатель на начало списка
	list* pointer_to_root = l;

	// Переходим ко второму звену
	l = l->next;

	// Очищаем первое звено
	l->prev->a = NULL;
	l->prev->next = NULL;

	// Отвязываем первое звено
	l->prev = NULL;

	// Перемещаем указатель на начало списка на второе звено
	*pointer_to_root = *l;
}