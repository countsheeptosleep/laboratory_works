#include <iostream>


using namespace std;



// Структуры:

// Структура узла очереди:
struct node {
    char data;
    int priority;
    node* next;
}; // Конец блока "Структура узла очереди"

// Структура очереди:
struct queue {
    node* start;
    node* end;
}; // Конец блока "Структура очереди"



// Функции:

// Функции для работы с очередями (основные):
void queue_create(queue* queue); // Функция создания очереди
void queue_print(queue* queue); // Функция печати очереди
void queue_add(queue* queue, char new_element, int new_element_priority); // Функция добавления нового элемента в очередь
void queue_clean(queue* queue); // Функция очистки очереди

// Функции для работы с очередями (дополнительные):
void queue_get_element_by_priority(queue* queue, int required_priority); // Функция выборки из очереди элемента с заданным значением приоритета 



// Основная программа:
int main() {


    // Подключим русский язык:
    setlocale(LC_ALL, "Russian");


    // Объявление переменных:
    queue* q = new queue; // Переменная для хранения очереди
    char new_element; // Новый элемент, который будет добавляться в очередь
    int new_element_priority; // Приоритет нового элемента, который будет добавляться в очередь
    int required_priority; // Заданное значение приоритета, по которому будем искать элементы в очереди 

    
    // Создаем очередь с помощью соответствующей функции и тут же печатаем ее:
    queue_create(q);
    queue_print(q); 


    // Получим от пользователя новый элемент для добавления в очередь:
    cout << "Введите новый элемент для добавления в очередь и его приоритет: ";
    cin >> new_element
        >> new_element_priority;


    // Добавим в очередь новый элемент и тут же распечатаем ее:
    queue_add(q, new_element, new_element_priority);
    queue_print(q);


    // Получим от пользователя приоритет для поиска по нему элемента в очереди:
    cout << "Введите приоритет для поиска по нему элемента в очереди: ";
    cin >> required_priority;


    // Найдем в очереди элемент по заданному приоритету:
    queue_get_element_by_priority(q, required_priority);

    // Очистим очередь и тут же попробуем распечатать пустую очередь:
    queue_clean(q);
    queue_print(q);


} // Конец блока "Основная программа"



// Функция создания очереди:
void queue_create(queue* queue) {


    // Объвление переменных:
    int N; // Количество элементов в очереди
    char element; // Очередной элемент очереди


    // Изначально очередь пуста и не имеет ни начала, ни конца:
    queue->start = NULL;
    queue->end = NULL;


    // Пригласим пользователя к вводу количества элементов очереди и считаем это значение:
    cout << "Введите количество элементов очереди: ";
    cin >> N;


    // Пригласим пользователя к вводу всех элементов очереди:
    cout << "Последовательно введите "
        << N 
        << " элементов очереди: ";

    
    // Последовательно считаем все элементы очереди и заполним ими очередь так, что наибольшой приоритет имеет меньшее значение:
    for (int i = 0; i < N; i++) {



        // ---------------------------------------------------------------------------------------------------------------------------------
        // ------------------------------- Часть 1: Считывание или создание переменных -----------------------------------------------------
        // ---------------------------------------------------------------------------------------------------------------------------------



        // Вводится очередной элемент:
        cin >> element;


        // Создадим для очередного элемента новый узел:
        node* new_node = new node;
        
        
        // Создадим узел, который будем использовать в качестве итератора:
        node* iterator_node;



        // ---------------------------------------------------------------------------------------------------------------------------------
        // -------------------- Часть 2: Заполнение очереди значениями в порядке их возрастания (убывания приоритета) ----------------------
        // ---------------------------------------------------------------------------------------------------------------------------------



        // Отдельно рассмотрим случай добавления первого элемента в очередь:
        if (i == 0) {


            // Единственный узел очереди будет ее и первым, и последним узлом:
            queue->start = new_node;
            queue->end = new_node;


            // Заполним этот узел значениями:
            new_node->data = element;
            new_node->priority = NULL;
            new_node->next = NULL;
           

            // Перейдем к считыванию следующих элементов:
            continue;


        } // Конец блока "Отдельно рассмотрим случай добавления первого элемента в очередь"


        // Отдельно рассмотрим случай, когда новый элемент меньше первого элемента в очереди:
        if (element < queue->start->data) {


            // Заполним новый узел значениями:
            new_node->data = element;
            new_node->priority = NULL;
            new_node->next = queue->start;


            // Новый элемент встал в начало очереди:
            queue->start = new_node;


        } // Конец блока "Отдельно рассмотрим случай, когда новый элемент меньше первого элемента в очереди"

        else { // Случай, когда новый элемент равен или меньше первого в очереди:


            // Установим "узел-итератор" на начало очереди:
            iterator_node = queue->start;


            // Идем по очереди до ее конца:
            while (iterator_node->next != NULL) {


                // Если новый элемент можно установить перед следующим:
                if (element < iterator_node->next->data) {


                    // Заполним новый узел значениями:
                    new_node->data = element;
                    new_node->priority = NULL;
                    new_node->next = iterator_node->next;


                    // Установим новый узел после данного узла:
                    iterator_node->next = new_node;


                    // Выйдем из цикла:
                    break;


                }


                // Перейдем к следующему узлу:
                iterator_node = iterator_node->next;


            } // Конец блока "Идем до очереди до ее конца"


            // Остается рассмотреть случай, когда элемент добавляется в самый конец очереди:
            if (iterator_node->next == NULL) {


                // Установим новый узел в конец очереди:
                iterator_node->next = new_node;


                // Заполним новый узел значениями:
                new_node->data = element;
                new_node->priority = NULL;
                new_node->next = NULL;


            } // Конец блока "Остается рассмотреть случай, когда элемент добавляется в самый конец очереди"

        } // Конец блока "Случай, когда новый элемент равен или меньше первого в очереди"



        // ---------------------------------------------------------------------------------------------------------------------------------
        // ---- Часть 3: Присвоение элементам их значений приоритета так, что приоритет варируется от нуля до числа элементов в очереди ----
        // ---------------------------------------------------------------------------------------------------------------------------------



        // Присвоим первому элементу очереди наивысший приоритет:
        queue->start->priority = N;


        // Установим "узел-итератор" на начало очереди:
        iterator_node = queue->start;


        // Пройдем по очереди и присвоим оставшимся элементам их значения приоритетов:
        while (iterator_node->next != NULL) {


            // Случай, если следующий элемент не равен данному: 
            if (iterator_node->data != iterator_node->next->data) {


                // Устанавливаем приоритет следующего элемента на значение на единицу меньшее приоритета данного:
                iterator_node->next->priority = iterator_node->priority - 1;


            } // Конец блока "Случай, если следующий элемент не равен данному"

            else { // Случай, если следующей элемент равен данному:


                // Устанавливаем приоритет следующего элемента равным приоритету данного элемента:
                iterator_node->next->priority = iterator_node->priority;


            }
       


            // Перейдем к следующему элементу очереди:
            iterator_node = iterator_node->next;


        }



    } // Конец блока "Последовательно считаем все элементы очереди"


}// Конец блока "Функция создания очереди"



// Функция печати очереди:
void queue_print(queue* queue) {


    // Создадим узел, с помощью которого будем "идти" по очереди от ее начала:
    node* iterator_node = queue->start;


    // Создадим флаг, чтобы отследить, не пуста ли очередь:
    bool flag_is_queue_empty = true;

    
    // Объявим пользователю о начале печати содержания очереди:
    cout << "Содержание очереди: ";


    // Пройдем по всей очереди и распечатаем хранящиеся в узлах данные:
    while (iterator_node != NULL) {


        // Отметим флагом, что данная очередь не пуста:
        flag_is_queue_empty = false;


        // Печать данных из очередного узла:
        cout << iterator_node->data

            << " (" << iterator_node->priority << ")"

            << "; ";


        // Переход к следующему узлу:
        iterator_node = iterator_node->next;


    } // Конец блока "Пройдем по всей очереди и распечатаем хранящиеся в узлах данные"


    // Рассмотрим случай, когда данная очередь пуста:
    if (flag_is_queue_empty) {


        // Объявим пользователю о том, что очередь пуста:
        cout << "Очередь пуста.";


    }


    // Сделаем отступ
    cout << endl << endl;


} // Конец блока "Функция печати очереди"



// Функция добавления нового элемента в очередь:
void queue_add(queue* queue, char new_element, int new_element_priority) {


    // Создадим новый узел для нового элемента:
    node* new_node = new node;
    new_node->data = new_element;
    new_node->priority = new_element_priority;
    new_node->next = NULL; // Пока что новый узел не связан с очередью


    // Создадим новый узел, который будем использовать в качестве итератора:
    node* iterator_node;


    // Случай, когда новый элемент имеет приоритет более высокий, чем первый элемент в очереди:
    if (new_element_priority > queue->start->priority) {


        // Следующим за новым узлом будет первый узел очереди:
        new_node->next = queue->start;


        // Новый элемент становится первым узлом очереди:
        queue->start = new_node;


    } // Конец блока "Случай, когда новый элемент имеет приоритет более высокий, чем первый элемент в очереди"
   
    else { // Случай, когда новый элемент имеет приоритет равный или меньший приоритета первого элемента очереди:


        // Установим "узел-итератор на начало очереди:
        iterator_node = queue->start;


        // Идем по очереди до ее конца:
        while (iterator_node->next != NULL) {


            // Если новый элемент можно установить перед следующим:
            if (new_element_priority > iterator_node->next->priority) {


                // За новым узлом будет следовать следующий узел:
                new_node->next = iterator_node->next;


                // Установим новый узел после данного узла:
                iterator_node->next = new_node;


                // Выйдем из цикла:
                break;


            }


            // Перейдем к следующему узлу:
            iterator_node = iterator_node->next;


        } // Конец блока "Идем до очереди до ее конца"


        // Остается рассмотреть случай, когда элемент добавляется в самый конец очереди:
        if (iterator_node->next == NULL) {


            // Установим новый узел в конец очереди:
            iterator_node->next = new_node;


        } // Конец блока "Остается рассмотреть случай, когда элемент добавляется в самый конец очереди"



    } // "Случай, когда новый элемент имеет приоритет равный или меньший приоритета первого элемента очереди"


} // Конец блока "Функция добавления нового элемента в очередь"



// Функция очистки очереди:
void queue_clean(queue* queue) {


    // Создадим узел, с помощью которого будем "идти" по очереди от ее начала:
    node* iterator_node = queue->start;


    // Объявим пользователю об очистке очереди:
    cout << "Очередь очищается." << endl;


    // Пройдем по всей очереди и очистим ее узлы:
    while (iterator_node != NULL) {


        // Очистим значения узла: число и его приоритет
        iterator_node->data = NULL;
        iterator_node->priority = NULL;

        
        // Временно запомним следующий узел:
        node* next_node = iterator_node->next;


        // Удалим из текущего узла запись о следующем узле:
        iterator_node->next = NULL;


        // Перейдем к следующему узлу:
        iterator_node = next_node;


    } // Конец блока "Пройдем по всей очереди и очистим ее узлы"


    // Удалим конец и начало очереди:
    queue->start = NULL;
    queue->end = NULL;


} // Конец блока "Функция очистки очереди"



// Функция выборки из очереди элемента с заданным значением приоритета:
void queue_get_element_by_priority(queue* queue, int required_priority) {


    // Совпадение приоритетов, согласно условию, разрешено.
    // Эта функция будет печатать все элементы с заданным значением приоритета.


    // Создадим узел, с помощью которого будем "идти" по очереди от ее начала:
    node* iterator_node = queue->start;


    // Создадим флаг, чтобы отследить, был ли найден хоть один элемент с заданным значением приоритета:
    bool flag_are_founded_any_nodes = false;


    // Объявим пользователю, что мы далее будем печатать:
    cout << "Элементы с заданным приоритетом: ";


    // Пройдем по всей очереди и найдем все элементы с заданным значением приоритета:
    while (iterator_node != NULL) {


        // Проверяем, обладает ли очередное значение необходимым приоритетом:
        if (iterator_node->priority == required_priority) {


            // Печатаем значение, имеющее подходящий приоритет:
            cout << iterator_node->data << "; ";


            // Отмечаем флагом то, что был найден хотя бы один подходящий элемент:
            flag_are_founded_any_nodes = true;


        } // Конец блока "Проверяем, обладает ли очередное значение необходимым приоритетом"
   
        else{  // Проверяем, если все числа с заданным приоритетом были найдены:

            if (flag_are_founded_any_nodes) {

                // Выходим из цикла
                break;

            }

        } // Конец блока "Проверяем, если все числа с заданным приоритетом были найдены"


        // Переходим к следующему узлу:
        iterator_node = iterator_node->next;


    } // Конец блока "Пройдем по всей очереди и найдем все элементы с заданным значением приоритета"


    // Рассмотрим случай, если не были найдены значения с подходящим приоритетом:
    if (!flag_are_founded_any_nodes) {

        
        // Выводим сообщение об отсутствии подходящих элементов:
        cout << "в очереди нет элементов с подходящим приоритетом";


    } // Конец блока "Рассмотрим случай, если не были найдены значения с подходящим приоритетом"


    // Сделаем отступ:
    cout << endl;


} // Конец блока "Функция выборки из очереди элемента с заданным значением приоритета"